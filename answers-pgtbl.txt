Q: Explain which relevant kernel data structures you had to modify to support superpages, and why.
A: I modified the physical memory allocator (kalloc.c) to support allocating and freeing valid 2MB (superpage) chunks. I added a new free list `kmem.freelist_huge` for these distinct chunks. In `vm.c`, I modified `uvmalloc` to detect when a requested allocation size and alignment allow for a superpage, and if so, allocate a huge page and map it directly into the page table at level 1, rather than using standard 4KB pages at level 0. I also updated `uvmunmap` and `uvmcopy` to correctly handle these huge pages by checking the page table level and flags.

Q: Why do we need a separate `walk` function or flag for superpages?
A: Standard page table walking typically resolves to the leaf node at level 0 (4KB). For superpages, the leaf is at level 1 (2MB). When allocating or mapping a superpage, we need to stop at level 1 and install the physical address there. If we used the standard walk which allocates level 0 tables, we would overwrite the level 1 entry with a pointer to a level 0 table, preventing us from creating a huge page. Thus, we implemented logic to manually walk or control the walk depth to install the superpage entry correctly.
